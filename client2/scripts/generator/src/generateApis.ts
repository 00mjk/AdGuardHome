/* eslint-disable no-template-curly-in-string */
/* eslint-disable @typescript-eslint/no-unused-expressions */
import * as fs from 'fs';
import * as path from 'path';
import { number } from 'prop-types';
// eslint-disable-next-line import/no-extraneous-dependencies
import * as morph from 'ts-morph';

import {
    API_DIR as API_DIR_CONST,
    BAD_REQUES_HELPER,
    GENERATOR_ENTITY_ALLIAS,
} from '../../consts';
import { toCamel, capitalize, schemaParamParser, OpenApi, uncapitalize, RequestBody } from './utils';


const API_DIR = path.resolve(API_DIR_CONST);
if (!fs.existsSync(API_DIR)) {
    fs.mkdirSync(API_DIR);
}

const { Project, QuoteKind } = morph;

enum PROCESS_AS {
    JSON = 'JSON',
    TEXT = 'TEXT',
    EMPTY = 'EMPTY',
}

class ApiGenerator {
    project = new Project({
        tsConfigFilePath: './tsconfig.json',
        manipulationSettings: {
            quoteKind: QuoteKind.Single,
            usePrefixAndSuffixTextForRename: false,
            useTrailingCommas: true,
        },
    });

    openapi: OpenApi;

    serverUrl: string;

    paths: any;

    /* interface Controllers {
        [controller: string]: {
            [operationId: string]: { parameters - from opneApi, responses - from opneApi, method }
        }
    } */
    controllers: Record<string, any> = {};

    apis: morph.SourceFile[] = [];

    methods = ['patch', 'delete', 'post', 'get', 'put', 'head', 'options', 'trace'];

    constructor(openapi: OpenApi) {
        this.openapi = openapi;
        this.paths = openapi.paths;
        this.serverUrl = openapi.servers[0].url;

        Object.keys(this.paths).forEach((pathKey) => {
            Object.keys(this.paths[pathKey]).filter((method) => this.methods.includes(method)).forEach((method) => {
                const {
                    tags, operationId, responses, requestBody, security, "x-skip-web-api": skip
                } = this.paths[pathKey][method];
                const parameters =  this.paths[pathKey][method].parameters || this.paths[pathKey].parameters;
                const controller = toCamel((tags ? tags[0] : pathKey.split('/')[1]));
                if (skip) {
                    return;
                }
                if (!operationId) {
                    console.log(pathKey);
                }
                if (this.controllers[controller]) {
                    this.controllers[controller][uncapitalize(operationId)] = {
                        parameters,
                        responses,
                        method,
                        requestBody,
                        security,
                        pathKey: pathKey.replace(/{/g, '${'),
                    };
                } else {
                    this.controllers[controller] = { [uncapitalize(operationId)]: {
                        parameters,
                        responses,
                        method,
                        requestBody,
                        security,
                        pathKey: pathKey.replace(/{/g, '${'),
                    } };
                }
            });
        });

        this.generateApiFiles();
    }

    generateApiFiles = () => {
        Object.keys(this.controllers).forEach(this.generateApiFile);
    };

    generateApiFile = (cName: string) => {
        const apiFile = this.project.createSourceFile(`${API_DIR}/${cName}.ts`);
        apiFile.addStatements([
            '// This file was autogenerated. Please do not change.',
            '// All changes will be overwrited on commit.',
            '',
        ]);

        // const schemaProperties = schemas[schemaName].properties;
        const importEntities: { type: string, isClass: boolean }[] = [];

        // add api class to file
        const apiClass = apiFile.addClass({
            name: `${capitalize(cName)}Api`,
            isDefaultExport: true,
        });

        // get operations of controller
        const controllerOperations = this.controllers[cName]; 
        const operationList = Object.keys(controllerOperations).sort();
        // for each operation add fetcher
        operationList.forEach((operation) => {
            const {
                requestBody, responses, parameters, method, pathKey,
            } = controllerOperations[operation];

            const queryParams:  { name: string, type: string, hasQuestionToken: boolean }[] = [];
            const bodyParam: { name: string, countedType: string, type?: string, isClass?: boolean, hasQuestionToken: boolean }[] = [];

            
            let contentType: string = '';

            if (parameters) {
                parameters.forEach((link: {$ref: string}) => {
                    const temp = link.$ref.split('/').pop()
                    const parameter = this.openapi.components.parameters[temp!];

                    const {
                        type, isArray, isClass, isImport,
                    } = schemaParamParser(parameter.schema, this.openapi);

                    if (isImport) {
                        importEntities.push({ type, isClass });
                    }
                    if (parameter.in === 'query') {
                        queryParams.push({
                            name: parameter.name, type: `${type}${isArray ? '[]' : ''}`, hasQuestionToken: !parameter.required });
                    }
                });
            }

            if (queryParams.length > 0) {
                const imp = apiFile.getImportDeclaration((i) => {
                    return i.getModuleSpecifierValue() === 'qs';
                }); if (!imp) {
                    apiFile.addImportDeclaration({
                        moduleSpecifier: 'qs',
                        defaultImport: 'qs',
                    });
                }
            }

            if (requestBody) {
                const { $ref }: { $ref: string } = requestBody;

                const name = $ref.split('/').pop();
                const { content, required } = this.openapi.components.requestBodies[name!];
                
                
                [contentType] = Object.keys(content);
                const data = content[contentType as keyof RequestBody['content']]!;

                const {
                    type, isArray, isClass, isImport,
                 } = schemaParamParser(data.schema, this.openapi);

                if (isImport) {
                    importEntities.push({ type: type, isClass });
                    bodyParam.push({
                        name: type.toLowerCase(),
                        countedType: `${isClass ? 'I' : ''}${type}${isArray ? '[]' : ''}`,
                        isClass,
                        type,
                        hasQuestionToken: !required
                    });
                } else {
                    bodyParam.push({
                        name: 'data',
                        countedType: `${type}${isArray ? '[]' : ''}`,
                        hasQuestionToken: !required });
                    
                }
            }

            const responsesCodes = Object.keys(responses);
            const responsesSchema = responsesCodes.map((code) => {
                const refLink = responses[code].$ref.split('/').pop();
                const ref = this.openapi.components.responses[refLink];
                
                interface ResponseSchema {
                    code: number,
                    [PROCESS_AS.JSON]?: ReturnType<typeof schemaParamParser>;
                    [PROCESS_AS.TEXT]?: {
                        schema?: ReturnType<typeof schemaParamParser>;
                        xErrorCode?: string;
                        onlyText: boolean;
                    }
                    [PROCESS_AS.EMPTY]?: boolean;
                }
                const responseSchema: ResponseSchema = { code: Number(code) };

                if (!ref.content) {
                    responseSchema[PROCESS_AS.EMPTY] = true;
                    return responseSchema;
                }
                if (ref.content?.['application/json']) {
                    const { schema } = ref.content['application/json'];
                    responseSchema[PROCESS_AS.JSON] = schemaParamParser(schema, this.openapi);
                } 
                if (ref.content?.['text/palin']) {
                    const {
                        "x-error-class": xErrorClass,
                        "x-error-code": xErrorCode,
                    } = ref.content['text/palin'];
                    if (xErrorClass) {
                        const schemaLink = xErrorClass.split('/').pop();
                        const schema = this.openapi.components.schemas[schemaLink!];
                        responseSchema[PROCESS_AS.TEXT] = {
                            schema: schemaParamParser(schema, this.openapi),
                            xErrorCode,
                            onlyText: false,
                        }
                    } else {
                        responseSchema[PROCESS_AS.TEXT] = { onlyText: true };
                    }
                }
                return responseSchema;
            });

            
            let returnTypes = new Set();

            bodyParam.forEach((param) => {
                if (param.isClass) {
                    returnTypes.add(BAD_REQUES_HELPER);
                    importEntities.push({ type: BAD_REQUES_HELPER, isClass: true });
                }
            })

            responsesSchema.forEach((responseSchema) => {
                if (responseSchema[PROCESS_AS.JSON]) {
                    const { type, isClass, isImport } = responseSchema[PROCESS_AS.JSON]!;
                    returnTypes.add(type);
                    if (isImport) {
                        importEntities.push({ type: type, isClass });
                    }
                }
                if (responseSchema[PROCESS_AS.TEXT]) {
                    const { onlyText, schema } = responseSchema[PROCESS_AS.TEXT]!;
                    if (onlyText) {
                        returnTypes.add('string');
                    } else {
                        const { type, isClass, isImport } = schema!;
                        returnTypes.add(type);
                        if (isImport) {
                            importEntities.push({ type, isClass });
                        }
                    }
                }
                if (responseSchema[PROCESS_AS.EMPTY]) {
                    returnTypes.add('number');
                }
            });
            returnTypes.add('undefined');
            const returnType = `Promise<${Array.from(returnTypes).join(' | ')}>`;

            const fetcher = apiClass.addMethod({
                isAsync: true,
                isStatic: true,
                name: operation,
                returnType,
            });
            const params = [...queryParams, ...bodyParam].sort((a, b) => (Number(!!a.hasQuestionToken) - Number(!!b.hasQuestionToken)));
            fetcher.addParameters(params);

            fetcher.setBodyText((w) => {
                if (contentType === 'application/json') {
                    const shouldValidate = bodyParam.filter(b => b.isClass);
                    if (shouldValidate.length > 0) {
                        w.writeLine(`const haveError: string[] = [];`);
                        shouldValidate.forEach((b) => {
                            w.writeLine(`haveError.push(...${b.name}.validate());`);
                        });
                        w.writeLine(`if (haveError.length > 0) {`);
                        w.writeLine(`    return Promise.resolve(new ${BAD_REQUES_HELPER}(haveError));`)
                        w.writeLine(`}`);
                    }
                }

                // Switch return of fetch in case on queryParams
                if (queryParams.length > 0) {
                    w.writeLine('const queryParams = {');
                    queryParams.forEach((q) => {
                        w.writeLine(`    ${q.name}: ${q.name},`);
                    });
                    w.writeLine('}');
                    w.writeLine(`return await fetch(\`${this.serverUrl}${pathKey}?\${qs.stringify(queryParams, { arrayFormat: 'comma' })}\`, {`);
                } else {
                    w.writeLine(`return await fetch(\`${this.serverUrl}${pathKey}\`, {`);
                }
                // Add method
                w.writeLine(`    method: '${method.toUpperCase()}',`);

                // add Fetch options
                if (contentType) {
                    w.writeLine(`    body: JSON.stringify(${bodyParam.map((b) => b.isClass ? `${b.name}.serialize()` : b.name).join(', ')}),`);
                }

                w.writeLine('}).then(async (res) => {');
                responsesSchema.forEach((responseSchema) => {
                    const { code } = responseSchema;
                    w.writeLine(`    if (res.status === ${code}) {`);
                    if (responseSchema[PROCESS_AS.EMPTY]) {
                        w.writeLine('        return res.status;');
                    }
                    if (responseSchema[PROCESS_AS.TEXT]?.onlyText) {
                        w.writeLine('        return res.text();')
                    }
                    if (responseSchema[PROCESS_AS.JSON] && responseSchema[PROCESS_AS.TEXT]) {
                        const { type } = responseSchema[PROCESS_AS.JSON]!;
                        const { schema, xErrorCode } = responseSchema[PROCESS_AS.TEXT]!;
                        const { type: errType } = schema!;
                        w.writeLine('        try {');
                        w.writeLine(`            return new ${type}(await res.json());`);
                        w.writeLine('        } catch {');
                        w.writeLine(`            return new ${errType}({ msg: await res.text() code: ${xErrorCode}} as any);`);
                        w.writeLine('        }');
                    }
                    if (responseSchema[PROCESS_AS.JSON]) {
                        const { type } = responseSchema[PROCESS_AS.JSON]!;
                        w.writeLine(`        return new ${type}(await res.json());`);
                    }
                    w.writeLine(`    }`);
                })
                w.writeLine('})');
            });
        });

        const imports: any[] = [];
        const types: string[] = [];
        importEntities.forEach((i) => {
            const { type } = i;
            if (!types.includes(type)) {
                imports.push(i);
                types.push(type);
            }
        });
        imports.sort((a,b) => a.type > b.type ? 1 : -1).forEach((ie) => {
            const { type: type, isClass } = ie;
            if (isClass) {
                apiFile.addImportDeclaration({
                    moduleSpecifier: `${GENERATOR_ENTITY_ALLIAS}${type}`,
                    defaultImport: type,
                });
            } else {
                apiFile.addImportDeclaration({
                    moduleSpecifier: `${GENERATOR_ENTITY_ALLIAS}${type}`,
                    namedImports: [type],
                });
            }
        });

        this.apis.push(apiFile);
    };

    save = () => {
        this.apis.forEach(async (e) => {
            await e.saveSync();
        });
    };
}


export default ApiGenerator;
