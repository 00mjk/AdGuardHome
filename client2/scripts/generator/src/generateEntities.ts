import * as fs from 'fs';
import * as path from 'path';
// eslint-disable-next-line import/no-extraneous-dependencies
import * as morph from 'ts-morph';

import { ENT_DIR, BAD_REQUES_HELPER } from '../../consts';
import { TYPES, toCamel, schemaParamParser, capitalize, OpenApi, Schema } from './utils';

const { Project, QuoteKind } = morph;


const EntDir = path.resolve(ENT_DIR);
if (!fs.existsSync(EntDir)) {
    fs.mkdirSync(EntDir);
}

class EntitiesGenerator {
    project = new Project({
        tsConfigFilePath: './tsconfig.json',
        manipulationSettings: {
            quoteKind: QuoteKind.Single,
            usePrefixAndSuffixTextForRename: false,
            useTrailingCommas: true,
        },
    });

    openapi: OpenApi;

    schemas:  Record<string, Schema>;

    schemaNames: string[];

    entities: morph.SourceFile[] = [];

    constructor(openapi: OpenApi) {
        this.openapi = openapi;
        this.schemas = openapi.components.schemas;
        this.schemaNames = Object.keys(this.schemas);
        this.generateEntities();
        this.generateUtils();
    }


    generateUtils = () => {
        const helperFile = this.project.createSourceFile(`${EntDir}/${BAD_REQUES_HELPER}.ts`);
        helperFile.addImportDeclaration({
            moduleSpecifier: `./BadRequestResp`,
            defaultImport: 'BadRequestResp',
        });
        helperFile.addImportDeclaration({
            moduleSpecifier: `./ErrorCode`,
            namedImports: ['ErrorCode'],
        });
        const helperClass = helperFile.addClass({
            name: 'BadRequestHelper',
            isDefaultExport: true,
            extends: 'BadRequestResp',
            properties: [{
                type: 'string[]',
                name: 'fields'
            }]
        });
        const helperConstructor = helperClass.addConstructor({
            parameters: [{
                type: 'string[]',
                name: 'fields'
            }],
        });
        helperConstructor.setBodyText((w) => {
            w.writeLine('super({ code: ErrorCode.JSN001, msg: \'Wrong fields value\' });');
            w.writeLine('this.fields = fields;')
        });
        this.entities.push(helperFile);
    }

    generateEntities = () => {
        this.schemaNames.forEach(this.generateEntity);
    };

    generateEntity = (schemaName: string) => {
        const { properties, type, oneOf, enum: en } = this.schemas[schemaName];
        const notAClass = !properties && TYPES[type as keyof typeof TYPES];

        if (oneOf) {
            this.generateOneOf(schemaName);
            return;
        }

        if (en) {
            this.generateEnum(schemaName);
            return;
        }
    
        if (notAClass) {
            this.generatePrimitive(schemaName)
        } else {
            this.generateClass(schemaName);
        } 
    };

    generatePrimitive = (schemaName: string) => {
        const entityFile = this.project.createSourceFile(`${EntDir}/${schemaName}.ts`);
        entityFile.addStatements([
            '// This file was autogenerated. Please do not change.',
            '',
        ]);
        const { type: schemaType, description, pattern } = this.schemas[schemaName];
        if (description) {
            entityFile.addStatements(['\n/*', `Description: ${description}`, '*/\n']);
        }

        if (pattern) {
            entityFile.addStatements(`const pattern = new RegExp('${pattern}')`);
        }

        const type: string = TYPES[schemaType as keyof typeof TYPES];

        const entityClass = entityFile.addClass({
            name: schemaName,
            isDefaultExport: true,
            extends: capitalize(type),
        });



        const ctor = entityClass.addConstructor({
            parameters: [{
                name: 'v',
                type,
                
            }],
        });
        ctor.setBodyText((w) => {
            const { minLength, minimum, maxLength, maximum } = this.schemas[schemaName];

            if (type === 'string') {
                if (pattern) {
                    w.writeLine('if (!v.match(pattern)) {');
                    w.writeLine('    throw new Error();');
                    w.writeLine('}');
                }
                if (typeof minLength === 'number') {
                    w.writeLine(`if (v.length < ${minLength}) {`);
                    w.writeLine('    throw new Error();');
                    w.writeLine('}');
                }
                if (typeof maxLength === 'number') {
                    w.writeLine(`if (v.length > ${maxLength}) {`);
                    w.writeLine('    throw new Error();');
                    w.writeLine('}');
                }
            }
            if (type === 'number') {
                if (typeof minimum === 'number') {
                    w.writeLine(`if (v.length < ${minimum}) {`);
                    w.writeLine('    throw new Error();');
                    w.writeLine('}');
                }
                if (typeof maximum === 'number') {
                    w.writeLine(`if (v.length > ${maximum}) {`);
                    w.writeLine('    throw new Error();');
                    w.writeLine('}');
                }
            }
            w.writeLine('super(v);');
        });

        this.entities.push(entityFile);
    };
    

    generateEnum = (schemaName: string) => {
        const entityFile = this.project.createSourceFile(`${EntDir}/${schemaName}.ts`);
        entityFile.addStatements([
            '// This file was autogenerated. Please do not change.',
            '',
        ]);
        const { enum: enumMembers, description, example } = this.schemas[schemaName];
        if (description) {
            entityFile.addStatements(['\n/*', `Description: ${description}`, '*/\n']);
        }
        entityFile.addEnum({
            name: schemaName,
            members: enumMembers!.map((e: string) => ({ name: e.toUpperCase(), value: e })),
            isExported: true,
        });

        this.entities.push(entityFile);
    };

    generateOneOf = (schemaName: string) => {
        const entityFile = this.project.createSourceFile(`${EntDir}/${schemaName}.ts`);
        entityFile.addStatements([
            '// This file was autogenerated. Please do not change.',
            '',
        ]);
        const importEntities: { type: string, isClass: boolean }[] = [];
        const entities = this.schemas[schemaName].oneOf.map((elem: any) => {
            const {
                type: type, isArray, isClass, isImport,
             } = schemaParamParser(elem, this.openapi);
            importEntities.push({ type: type, isClass });
            return { type: type, isArray };
        });
        entityFile.addTypeAlias({
            name: schemaName,
            isExported: true,
            type: entities.map((e: any) => e.isArray ? `I${e.type}[]` : `I${e.type}`).join(' | '),
        })

        // add import
        importEntities.sort((a, b) => a.type > b.type ? 1 : -1).forEach((ie) => {
            const { type: type, isClass } = ie;
            if (isClass) {
                entityFile.addImportDeclaration({
                    moduleSpecifier: `./${type}`,
                    namedImports: [`I${type}`],
                });
            } else {
                entityFile.addImportDeclaration({
                    moduleSpecifier: `./${type}`,
                    namedImports: [type],
                });
            }
        });
        this.entities.push(entityFile);
    }

    generateClass = (schemaName: string) => {
        const entityFile = this.project.createSourceFile(`${EntDir}/${schemaName}.ts`);
        entityFile.addStatements([
            '// This file was autogenerated. Please do not change.',
            '',
        ]);

        let { properties, required, allOf, $ref } = this.schemas[schemaName];

        if (allOf) {
            const refLink: string = allOf.find((obj: Record<string, any>) => obj.$ref).$ref;
            let ref: any = refLink.split('/')
            ref = ref.pop();
            
            const reasign = allOf.find((obj: Record<string, any>) => !obj.$ref);
            const newSchema: Schema = { ...this.schemas[ref], ...reasign };

            properties = newSchema.properties;
            required = newSchema.required;
        }

        if ($ref) {
            const refLink = $ref.split('/').pop()!;
            entityFile.addImportDeclaration({
                defaultImport: refLink,
                moduleSpecifier: `./${refLink}`,
                namedImports: [`I${refLink}`],
            });

            entityFile.addTypeAlias({
                name: `I${schemaName}`,
                type: `I${refLink}`,
                isExported: true,
            })

            const entityClass = entityFile.addClass({
                name: schemaName,
                isDefaultExport: true,
                extends: refLink,
            })
            const ctor = entityClass.addConstructor({
                parameters: [{
                    name: 'props',
                    type: `I${schemaName}`,
                }],
            })
            ctor.setBodyText((w) => {
                w.writeLine('super(props);')
            });
            this.entities.push(entityFile);
            return;
        }
        

        const entityInterface = entityFile.addInterface({
            name: `I${schemaName}`,
            isExported: true,
        });
    
        const sortedProperties = Object.keys(properties || {}).sort();
        let importEntities: { type: string, isClass: boolean }[] = [];

        type SortedPropertiesTypesValues =  ReturnType<typeof schemaParamParser> & {
            computedType: string;
            isRequired: boolean;
        }
        const sortedPropertiesTypes = sortedProperties.reduce((data, propertyName) => {
            const isRequired = !!(required && required.includes(propertyName));
            const parsed = schemaParamParser(properties![propertyName], this.openapi);
            data[propertyName] = {
                ...parsed,
                isRequired,
                computedType: `${parsed.type}${parsed.isArray ? '[]' : ''}${isRequired ? '' : ' | undefined'}`
            };
            return data;
        }, {} as Record<string, SortedPropertiesTypesValues>);

        // add server response interface to entityFile
        sortedProperties.forEach((propertyName) => {
            const {
                type, isArray, isClass, isImport
            } = sortedPropertiesTypes[propertyName];

            if (isImport) {
                importEntities.push({ type: type, isClass });
            }
            entityInterface.addProperty({
                name: propertyName,
                type: `${isClass ? 'I' : ''}${type}${isArray ? '[]' : ''}`,
                hasQuestionToken: !(
                    (required && required.includes(propertyName)) || properties![propertyName].required
                ),
            });
        });

        // add import
        const types: string[] = [];
        importEntities = importEntities.filter((i) => {
            const { type } = i;
            if (!types.includes(type)) {
                types.push(type);
                return true;
            }
            return false;
        });
        importEntities.sort((a, b) => a.type > b.type ? 1 : -1).forEach((ie) => {
            const { type: type, isClass } = ie;
            if (isClass) {
                entityFile.addImportDeclaration({
                    defaultImport: type,
                    moduleSpecifier: `./${type}`,
                    namedImports: [`I${type}`],
                });
            } else {
                entityFile.addImportDeclaration({
                    moduleSpecifier: `./${type}`,
                    namedImports: [type],
                });
            }
        });

        const entityClass = entityFile.addClass({
            name: schemaName,
            isDefaultExport: true,
        });

        // addProperties to class;
        sortedProperties.forEach((propertyName) => {
            const { type, isArray, isClass, isEnum, isRequired, computedType } = sortedPropertiesTypes[propertyName];

            entityClass.addProperty({
                name: `_${propertyName}`,
                isReadonly: true,
                type: computedType,
            });

            const getter = entityClass.addGetAccessor({
                name: toCamel(propertyName),
                returnType: computedType,
                statements: [`return this._${propertyName};`],
            });
            const { description, example, minItems, maxItems, maxLength, minLength, maximum, minimum } = properties![propertyName];

            if (description || example) {
                getter.addJsDoc(`${example ? `Description: ${description}` : ''}${example ? `\nExample: ${example}` : ''}`);
            }

            if (minItems) {
                entityClass.addProperty({
                    isStatic: true,
                    isReadonly: true,
                    name: `${capitalize(toCamel(propertyName))}MinItems`,
                    initializer: `${minItems}`,
                });
            }
            if (maxItems) {
                entityClass.addProperty({
                    isStatic: true,
                    isReadonly: true,
                    name: `${capitalize(toCamel(propertyName))}MaxItems`,
                    initializer: `${maxItems}`,
                });
            }
            if (typeof minLength === 'number') {
                entityClass.addProperty({
                    isStatic: true,
                    isReadonly: true,
                    name: `${capitalize(toCamel(propertyName))}MinLength`,
                    initializer: `${minLength}`,
                });
            }
            if (maxLength) {
                entityClass.addProperty({
                    isStatic: true,
                    isReadonly: true,
                    name: `${capitalize(toCamel(propertyName))}MaxLength`,
                    initializer: `${maxLength}`,
                });
            }
            if (typeof minimum === 'number') {
                entityClass.addProperty({
                    isStatic: true,
                    isReadonly: true,
                    name: `${capitalize(toCamel(propertyName))}MinValue`,
                    initializer: `${minimum}`,
                });
            }
            if (maximum) {
                entityClass.addProperty({
                    isStatic: true,
                    isReadonly: true,
                    name: `${capitalize(toCamel(propertyName))}MaxValue`,
                    initializer: `${maximum}`,
                });
            }
        });

        // add constructor;
        const ctor = entityClass.addConstructor({
            parameters: [{
                name: 'props',
                type: `I${schemaName}`,
            }],
        });
        ctor.setBodyText((w) => {
            sortedProperties.forEach((propertyName) => {
                const { type, isArray, isClass, isRequired } = sortedPropertiesTypes[propertyName];
                
                const indent = !isRequired ? '    ' : '';
                if (!isRequired) {
                    if ((type === 'boolean' || type === 'number' || type ==='string') && !isClass && !isArray) {
                        w.writeLine(`if (typeof props.${propertyName} === '${type}') {`);
                    } else {
                        w.writeLine(`if (props.${propertyName}) {`);
                    }
                }
                if (isArray && isClass) {
                    w.writeLine(`${indent}this._${propertyName} = props.${propertyName}.map((p) => new ${type}(p));`);
                } else if (isClass) {
                    w.writeLine(`${indent}this._${propertyName} = new ${type}(props.${propertyName});`);
                } else {
                    if (type === 'string' && !isArray) {
                        w.writeLine(`${indent}this._${propertyName} = props.${propertyName}.trim();`);
                    } else {
                        w.writeLine(`${indent}this._${propertyName} = props.${propertyName};`);
                    }
                }
                if (!isRequired) {
                    w.writeLine('}');
                }
            });
        });

        // add serialize method;
        const serialize = entityClass.addMethod({
            isStatic: false,
            name: 'serialize',
            returnType: `I${schemaName}`,
        });
        serialize.setBodyText((w) => {
            w.writeLine(`const data: I${schemaName} = {`);
            
            const unReqFields: string[] = [];

            sortedProperties.forEach((propertyName) => {
                const {isArray, isClass, isRequired } = sortedPropertiesTypes[propertyName];
                if (!isRequired) {
                    unReqFields.push(propertyName);
                    return;
                }
                if (isArray && isClass) {
                    w.writeLine(`    ${propertyName}: this._${propertyName}.map((p) => p.serialize()),`);
                } else if (isClass) {
                    w.writeLine(`    ${propertyName}: this._${propertyName}.serialize(),`);
                } else {
                    w.writeLine(`    ${propertyName}: this._${propertyName},`);
                    
                }
            });
            w.writeLine('};');
        
            unReqFields.forEach((propertyName) => {
                const { isArray, isClass } = sortedPropertiesTypes[propertyName];
                w.writeLine(`if (typeof this._${propertyName} !== 'undefined') {`);
                if (isArray && isClass) {
                    w.writeLine(`    data.${propertyName} = this._${propertyName}.map((p) => p.serialize());`);
                } else if (isClass) {
                    w.writeLine(`    data.${propertyName} = this._${propertyName}.serialize();`);
                } else {
                    w.writeLine(`    data.${propertyName} = this._${propertyName};`);
                    
                }
                w.writeLine(`}`);
            });
            w.writeLine('return data;');
        });

        // add validate method
        const validate = entityClass.addMethod({
            isStatic: false,
            name: 'validate',
            returnType: `string[]`,
        })
        validate.setBodyText((w) => {
            w.writeLine('const validateRequired = {');
            Object.keys(properties || {}).forEach((propertyName) => {
                const { isArray, isClass, type, isRequired } = sortedPropertiesTypes[propertyName];
                const { maxLength, minLength, maximum, minimum } = properties![propertyName];

                const nonRequiredCall = isRequired ? `this._${propertyName}` : `!this._${propertyName} ? true : this._${propertyName}`;

                if (isArray && isClass) {
                    w.writeLine(`    ${propertyName}: ${nonRequiredCall}.reduce<boolean>((result, p) => result && p.validate().length === 0, true),`);
                } else if (isClass) {
                    w.writeLine(`    ${propertyName}: ${nonRequiredCall}.validate().length === 0,`);        
                } else {
                    if (type === 'string') {
                        if (isArray) {
                            w.writeLine(`    ${propertyName}: ${nonRequiredCall}.reduce<boolean>((result, p) => result && typeof p === 'string', true),`);
                        } else {
                            if (typeof minLength === 'number' && maxLength) {
                                w.writeLine(`    ${propertyName}: (${nonRequiredCall}.length >${minLength > 0 ? '=' : ''} ${minLength}) && (${nonRequiredCall}.length <= ${maxLength}),`);
                            }
                            if (typeof minLength !== 'number' || !maxLength) {
                                w.writeLine(`    ${propertyName}: ${isRequired ? `typeof this._${propertyName} === 'string' && !!this._${propertyName}.trim()` : `!this._${propertyName} ? true : typeof this._${propertyName} === 'string'`},`);
                            }
                        }
                    } else if (type === 'number') {
                        if (isArray) {
                            w.writeLine(`    ${propertyName}: ${nonRequiredCall}.reduce<boolean>((result, p) => result && typeof p === 'number', true),`);
                        } else {
                            if (typeof minimum === 'number' && maximum) {
                                w.writeLine(`    ${propertyName}: ${isRequired ? `this._${propertyName} >= ${minimum} && this._${propertyName} <= ${maximum}` : `!this._${propertyName} ? true : ((this._${propertyName} >= ${minimum}) && (this._${propertyName} <= ${maximum}))`},`);
                            }
                            if (typeof minimum !== 'number' || !maximum) {
                                w.writeLine(`    ${propertyName}: ${isRequired ? `typeof this._${propertyName} === 'number'` : `!this._${propertyName} ? true : typeof this._${propertyName} === 'number'`},`);
                            }
                        }
                    } else if (type === 'boolean') {
                        w.writeLine(`    ${propertyName}: ${isRequired ? `typeof this._${propertyName} === 'boolean'` : `!this._${propertyName} ? true : typeof this._${propertyName} === 'boolean'`},`);
                    }
                }
            });
            w.writeLine('};');
            w.writeLine('const errorInFields: string[] = [];')
            w.writeLine('Object.keys(validateRequired).forEach((key) => {');
            w.writeLine('    if (!(validateRequired as any)[key]) {');
            w.writeLine('        errorInFields.push(key);');
            w.writeLine('    }');
            w.writeLine('});');
            w.writeLine('return errorInFields;');
        });

        this.entities.push(entityFile);
    };

    save = () => {
        this.entities.forEach(async (e) => {
            await e.saveSync();
        });
    };
}

export default EntitiesGenerator;
